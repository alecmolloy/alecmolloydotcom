<!doctype html>
<html lang="en">

<head>
	<title>Emotional Emoji</title>
	<meta charset="utf-8">
	<style>
		#overlay {
			position: absolute;
			top: 0px;
			left: 0px;
		}

		#container {
			position: relative;
			width: 700px;
			height: 500px;
		}

		#emoji {
			position: absolute;
			top: 0;
			left: 0;
			font-size: 128px;
			-webkit-filter:scale(.9);
		}

		#content {
			margin-top: 70px;
			margin-left: 100px;
			margin-right: 100px;
			max-width: 950px;
		}

		#sketch,
		#filter {
			display: none;
		}

		h2 {
			font-weight: 400;
		}

		.hide {
			display: none;
		}
	</style>
</head>

<body>
	<script src="js/clmtrackr.js"></script>
	<script src="js/model_pca_20_svm_emotionDetection.js"></script>
	<script src="js/emotion_classifier.js"></script>
	<script src="js/emotionmodel2.js"></script>

	<div id="content">
		<h2>Emotional Emoji</h2>
		<div id="container">
			<canvas id="image" width="625" height="500"></canvas>
			<canvas id="overlay" width="625" height="500"></canvas>
			<div id="emoji"></div>
		</div>
		<br/>
		<input type="button" class="btn" value="start" onclick="animateClean()"></input>
		<input type="file" class="btn" id="files" name="files[]" />

		<script>
			var cc = document.getElementById('image').getContext('2d');
			var overlay = document.getElementById('overlay');
			var overlayCC = overlay.getContext('2d');

			var ctrack = new clm.tracker({
				stopOnConvergence: true
			});
			ctrack.init(pModel);

			var drawRequest;

			function animateClean() {
				ctrack.start(document.getElementById('image'));
				drawLoop();
			}

			var emoji = document.getElementById('emoji');




			var img = new Image();
			img.onload = function () {
				cc.drawImage(img, 0, 0, 625, 500);
			};
			img.src = 'img/barry.jpg';









			function drawEmoji() {
				var cp = ctrack.getCurrentParameters();
				var er = ec.predict(cp);
				var maxVal = 0;
				var emotion;
				for (var i in er) {
					if (er[i].value > maxVal) {
						maxVal = er[i].value;
						emotion = er[i].emotion;
					}
				}

				var emotions = {
					angry : 'ðŸ˜ ',
					disgusted : 'ðŸ˜°',
					fear : 'ðŸ˜±',
					sad : 'ðŸ˜­',
					surprised : 'ðŸ˜®',
					happy : 'ðŸ˜Ž',
				}
				console.log(emotion);
				emoji.innerHTML = emotions[emotion];

				var position = ctrack.getCurrentPosition()[41];
				var x = position[0];
				var y = position[1];
				emoji.style.left = (x - 64) + 'px';
				emoji.style.top = (y - 64) + 'px';
			}

			function drawLoop() {
				drawRequest = requestAnimationFrame(drawLoop);
				overlayCC.clearRect(0, 0, 720, 576);
				if (ctrack.getCurrentPosition()) {
//					ctrack.draw(overlay);
				}
			}

			var ec = new emotionClassifier();
			ec.init(emotionModel);
			var emotionData = ec.getBlank();


			// detect if tracker fails to find a face
			document.addEventListener("clmtrackrNotFound", function (event) {
				ctrack.stop();
				alert("The tracking had problems with finding a face in this image.")
			}, false);

			// detect if tracker loses tracking of face
			document.addEventListener("clmtrackrLost", function (event) {
				ctrack.stop();
				alert("The tracking had problems converging on a face in this image.")
			}, false);

			// detect if tracker has converged
			document.addEventListener("clmtrackrConverged", function (event) {
				// stop drawloop
				cancelAnimationFrame(drawRequest);
				drawEmoji();
			}, false);

			// function to start showing images
			function loadImage() {
				if (fileList.indexOf(fileIndex) < 0) {
					var reader = new FileReader();
					reader.onload = (function (theFile) {
						return function (e) {
							// check if positions already exist in storage

							// Render thumbnail.
							var canvas = document.getElementById('image')
							var cc = canvas.getContext('2d');
							var img = new Image();
							img.onload = function () {
								if (img.height > 500 || img.width > 700) {
									var rel = img.height / img.width;
									var neww = 700;
									var newh = neww * rel;
									if (newh > 500) {
										newh = 500;
										neww = newh / rel;
									}
									canvas.setAttribute('width', neww);
									canvas.setAttribute('height', newh);
									cc.drawImage(img, 0, 0, neww, newh);
								} else {
									canvas.setAttribute('width', img.width);
									canvas.setAttribute('height', img.height);
									cc.drawImage(img, 0, 0, img.width, img.height);
								}
							}
							img.src = e.target.result;
						};
					})(fileList[fileIndex]);
					reader.readAsDataURL(fileList[fileIndex]);
					overlayCC.clearRect(0, 0, 720, 576);
					ctrack.reset();
				}

			}

			// set up file selector and variables to hold selections
			var fileList, fileIndex;
			if (window.File && window.FileReader && window.FileList) {
				function handleFileSelect(evt) {
					var files = evt.target.files;
					fileList = [];
					for (var i = 0; i < files.length; i++) {
						if (!files[i].type.match('image.*')) {
							continue;
						}
						fileList.push(files[i]);
					}
					if (files.length > 0) {
						fileIndex = 0;
					}

					loadImage();
				}
				document.getElementById('files').addEventListener('change', handleFileSelect, false);
			}
		</script>
	</div>
</body>

</html>
